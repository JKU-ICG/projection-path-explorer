<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>General Visualization</title>



    <script src="util.js"></script>
    <script src="https://d3js.org/d3.v4.min.js" charset="utf-8"></script>

    <script
      src="https://code.jquery.com/jquery-3.4.1.min.js"
      integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
      crossorigin="anonymous"></script>



    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


    <script src="rubik.js"></script>
    <script src="chess.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/109/three.min.js" integrity="sha256-Wua0LsQkGDEeIkbmBNjj9wcThJh5uCD6R8+5YQhXveQ=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/three.meshline@1.2.0/src/THREE.MeshLine.min.js"></script>
    <link rel="stylesheet" href="chess.css">
    <link rel="stylesheet" href="styling.css">
    <link href="rubics.png" rel="shortcut icon" type="image/x-icon" />



    <script src="LineSegmentsGeometry.js"></script>
    <script src="LineMaterial.js"></script>
    <script src="LineGeometry.js"></script>
    <script src="LineSegments2.js"></script>
    <script src="Line2.js"></script>
  </head>

  <body onresize="onWindowResize()">
    <div class="d-flex align-items-stretch" style="width: 100vw; height: 100vh">
      <div id="container" class="flex-shrink-1 flex-grow-1"></div>

      <div style="width: 18rem; margin: 0.5rem" class="card flex-shrink-0">
        <div id="info" class="d-flex align-items-center justify-content-center" style="height: 50%"></div>
        <div id="aggregate" class="d-flex align-items-center justify-content-center" style="height: 50%"></div>
      </div>

      <div class="card flex-shrink-0" style="width: 18rem; margin: 0.5rem;">

        <div class="container" style="padding-top: 1rem;">
          <select name="cars" class="custom-select" onchange="selectDataset(this)">
            <option selected>Choose data set</option>
            <option value="chess_chess16k.csv">Chess 16k Games</option>
            <option value="chess_chess16k.csv">Chess 40k Games</option>
            <option value="rubik_cube1x2_different_origins.csv">Rubik 1x2 Different Origins</option>
            <option value="rubik_cube5x2_different_origins.csv">Rubik 5x2 Different Origins</option>
            <option value="rubik_cube10x2_different_origins.csv">Rubik 10x2 Different Origins</option>
            <option value="rubik_cube100x2_different_origins.csv">Rubik 100x2 Different Origins</option>
          </select>

          <div class="custom-file">
            <input type="file" class="custom-file-input" id="customFile">
            <label class="custom-file-label" for="customFile">Choose file</label>
          </div>
        </div>

        <div id="legend"></div>
      </div>
    </div>



		<script type="x-shader/x-vertex" id="vertexshader">

      // Uniforms
      uniform float zoom;

      // Attributes of point sprites
      attribute float size;
      attribute vec4 customColor;
      attribute float type;

      // Varying of point sprites
			varying vec4 vColor;
      varying float vType;

			void main() {
				vColor = customColor;
        vType = type;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_PointSize = size + (zoom / 15.0);
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">
			uniform vec3 color;
			uniform sampler2D pointTexture[4];
			varying vec4 vColor;
      varying float vType;

			void main() {
        gl_FragColor = vColor;
        if (vType == 0.0) {
          gl_FragColor = gl_FragColor * texture2D(pointTexture[0], gl_PointCoord);
        } else if (vType == 1.0) {
          gl_FragColor = gl_FragColor * texture2D(pointTexture[1], gl_PointCoord);
        } else if (vType == 2.0) {
          gl_FragColor = gl_FragColor * texture2D(pointTexture[2], gl_PointCoord);
        } else {
          gl_FragColor = gl_FragColor * texture2D(pointTexture[3], gl_PointCoord);
        }

				if ( gl_FragColor.a < ALPHATEST ) discard;
			}
		</script>

		<script>


          var problem = null


          var loaded = null;
          var segments = null;
    			var camera;
    			var particles;
    			var PARTICLE_SIZE = 20;
    			var raycaster, intersects;
    			var mouse, INTERSECTED;
          var pointGeometry = null;
          var mouseDownPosition = null;
          var mouseDown = false;
          var strokeTexture = null;
          var pointMaterial = null;

          var settings = {
            showIntPoints: false
          }

          var currentHoverIdx = null;

          function * colorGenerator() {
            yield 0x7D3C98
            yield 0x148F77
            yield 0xFFC300
          }
          var chooseColor = colorGenerator();

          var algorithms = { };


    /**
     * Checkbox determining if intermediate points should be drawn.
     */
    function showIntermediatePoints() {
      settings.showIntPoints = !settings.showIntPoints

      updatePointGeometry()
    }



    function onShowBeginnerMethodChanged(element) {
      // show/hide lines that belong to fridrich method
      segments.forEach((segment) => {
        if (segment.algo == 0) {
          segment.line.visible = element.checked


          segment.vectors.forEach((vector) => {
            if (vector.algo == 0) {
              vector.visible = element.checked
            }
          })
        }
      })

      updatePointGeometry()
    }

    function onShowFridrichMethodChanged(element) {
      var show = element.checked

      // show/hide lines that belong to fridrich method
      segments.forEach((segment) => {
        if (segment.algo == 1) {
          segment.line.visible = show


          segment.vectors.forEach((vector) => {
            if (vector.algo == 1) {
              vector.visible = element.checked
            }
          })
        }
      })


      updatePointGeometry()
    }



    function selectDataset(select) {
      cleanup()

      if (select.value.startsWith("chess")) {
        problem = new Problem(ProblemType.CHESS)
        loadData(problem, "datasets/chess/" + select.value.substring(6))
      } else if (select.value.startsWith("rubik")) {
        problem = new Problem(ProblemType.RUBIK)
        loadData(problem, "datasets/rubik/" + select.value.substring(6));
      }
    }


      /**
       * Rectangle selection tool.
       */
      class RectangleSelection {
        constructor(vectors, settings) {
          this.vectors = vectors
          this.settings = settings
        }

        mouseDown(x, y) {
          this.geometry = new THREE.PlaneGeometry(1, 1, 32);
          this.material = new THREE.MeshBasicMaterial({
            color: 0xffff00,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.5
          });
          this.plane = new THREE.Mesh(this.geometry, this.material);
          this.plane.position.x = x
          this.plane.position.y = y
          this.plane.scale.x = 0
          this.plane.scale.y = 0

          this.startX = x
          this.startY = y

          problem.scene.add(this.plane);
        }

        mouseMove(x, y) {
          var w = x - this.startX
          var h = y - this.startY
          this.plane.scale.x = w
          this.plane.scale.y = h
          this.plane.position.x = x - w / 2
          this.plane.position.y = y - h / 2
        }

        mouseUp() {
          problem.scene.remove(this.plane)

          var width = Math.abs(this.plane.scale.x)
          var height = Math.abs(this.plane.scale.y)
          var vectors = this.select({ x: this.plane.position.x - width / 2, y: this.plane.position.y - height / 2, w: width, h: height })

          // Create aggregation
          if (vectors.length > 0) {
            var html = problem.aggregate(vectors)

            document.getElementById('aggregate').innerHTML = html
          }


          this.geometry.dispose()
          this.material.dispose()
        }

        dispose() {
          problem.scene.remove(this.plane)

          this.geometry.dispose()
          this.material.dispose()
        }

        select(rect) {
          var set = []

          this.vectors.forEach((vector, index) => {
            if (this.settings.showIntPoints || vector.cp == 1) {
              if (vector.x > rect.x && vector.y > rect.y && vector.x < rect.x + rect.w && vector.y < rect.y + rect.h) {
                set.push(vector)
              }
            }
          })

          return set
        }
      }


      var rectangleSelection = null



      function cleanup() {
        if (problem != null) {
          problem.scene.dispose()
        }
      }



      /**
       * Loads a specific problem set, creating menus, displaying vectors etc.
       */
      function loadData(problem, file) {


        // Load csv file
        d3.csv(file, function loadCallback(error, data) {

          data.forEach(function(d) { // convert strings to numbers
              // Convert generic attributes
              d.y = +d.y
              d.x = +d.x
              d.cubeNum = +d.cubeNum
              d.cp = +d.cp
              d.algo = +d.algo
              d.age = +d.age

              // Attribute that specifies if this vector should be visible or not
              d.visible = true

              if (!(d.algo in algorithms)) {
                algorithms[d.algo] = {
                  color: chooseColor.next().value
                }
              }
            });
            loaded = data;

            segments = getSegments(loaded);

            init(loaded, problem);

            updatePointGeometry()

            loadLegend(problem);

            animate();
        })
      }

      function loadLegend(problem) {
        if (problem.type == ProblemType.RUBIK) {
          document.getElementById('legend').innerHTML = rubikLegend(algorithms[1].color, algorithms[0].color)
        } else {
          document.getElementById('legend').innerHTML = chessLegend(algorithms[1].color, algorithms[0].color)
        }
      }






      function getSegments(data) {
        //creating an array holding arrays of x,y,cubenum,algo,age for each cube

        // Sort data by cubeNum
        data.sort((a, b) => a.cubeNum - b.cubeNum)


        var n = data.length
        var points = new Array()
        var currentCube = 0
        var newArray = { vectors: new Array(), algo: data[0].algo }
        for (var i = 0; i < n; i++) {
          if(data[i].cubeNum != currentCube) {
            points.push(newArray)
            currentCube = data[i].cubeNum

            newArray = { vectors: new Array(), algo: data[i].algo }
          }

          newArray.vectors.push(data[i])
        }
        points.push(newArray)
        return points
    }




function intToComponents(colorBeginner) {
    var compBeginner = {
      r: (colorBeginner & 0xff0000) >> 16,
      g: (colorBeginner & 0x00ff00) >> 8,
      b: (colorBeginner & 0x0000ff)
    };

    return compBeginner
}

    function fatLines(segments) {
      segments.forEach(function(segment, index) {
        var colors = []
        var positions = []

        var geometry = new THREE.LineGeometry();

        var matLine = new THREE.LineMaterial({
                linewidth: 10, // in pixels
                vertexColors: THREE.VertexColors,
                transparent: true,
                opacity: 0.5,
                depthWrite: false
            });
        matLine.resolution.set(776, 695);

        var da = []
        segment.vectors.forEach(function(vector, vi) {

          da.push(new THREE.Vector2(vector.x, vector.y))
          //geometry.vertices.push(new THREE.Vector3(vector.x, vector.y, -1.0));
        })

        var curve = new THREE.SplineCurve(da)
        var color = algorithms[segment.vectors[0].algo].color
        var rgb = intToComponents(color)

        curve.getPoints(1000).forEach(function(p, i) {
          positions.push(p.x, p.y, -1.0)
          colors.push(rgb.r / 255.0, rgb.g / 255.0, rgb.b / 255.0)
        })

        geometry.setPositions(positions)
        geometry.setColors(colors)

        var line = new THREE.Line2(geometry, matLine);

        // Store line data in segment...
        segment.line = line


        problem.scene.add(line)
      })
    }



    function renderLines(segments) {
      segments.forEach(function(segment, index) {
        var geometry = new THREE.Geometry();

        var material = new THREE.LineBasicMaterial({
            color: algorithms[segment.vectors[0].algo].color,
            transparent: true,

            // Calculate opacity
            opacity: 0.3 + 0.7 / segments.length
            // 1 - 1     100 - 0.1    200 - 0.05      50 - 0.2     25 - 0.4
        });
        var da = []
        segment.vectors.forEach(function(vector, vi) {
          da.push(new THREE.Vector2(vector.x, vector.y))
          //geometry.vertices.push(new THREE.Vector3(vector.x, vector.y, -1.0));
        })

        var curve = new THREE.SplineCurve(da)

        curve.getPoints(1000).forEach(function(p, i) {
          geometry.vertices.push(new THREE.Vector3(p.x, p.y, -1.0))
        })
        var line = new THREE.Line( geometry, material );

        // Store line data in segment...
        segment.line = line

        problem.scene.add(line)
      })
    }


    function onDocumentMouseUp(e) {

      var test = mouseToWorld(e)

      if (rectangleSelection != null) {
        rectangleSelection.mouseUp(test.x, test.y)
        rectangleSelection = null
      }


      mouseDown = false;
    }

    function onDocumentMouseDown(e) {
      e.preventDefault();

      var container = document.getElementById( 'container' );
      var width = container.offsetWidth;
      var height = container.offsetHeight;

      if (e.altKey) {
        // Selection processing
        if (rectangleSelection != null) {
          rectangleSelection.dispose()
          rectangleSelection = null
        }

        rectangleSelection = new RectangleSelection(loaded, settings)

        var test = mouseToWorld(event)

        rectangleSelection.mouseDown(test.x, test.y)

      } else {
        // Dragging data around
        mouseDownPosition = normaliseMouse(e)
        mouseDown = true;
      }
    }

    function mouseToWorld(event) {
      var container = document.getElementById( 'container' );
      var width = container.offsetWidth;
      var height = container.offsetHeight;

      const rect = container.getBoundingClientRect();

      var test = {
        x: (event.clientX - rect.left - width / 2) / camera.zoom + camera.position.x,
        y: -(event.clientY - rect.top - height / 2) / camera.zoom + camera.position.y
      }

      return test
    }

    function onDocumentMouseMove( event ) {
      event.preventDefault();

      var test = mouseToWorld(event)



      if (rectangleSelection != null) {
        rectangleSelection.mouseMove(test.x, test.y)
      }




      if (window.infoTimeout != null) {
        clearTimeout(window.infoTimeout)
      }
      window.infoTimeout = setTimeout(function() {
        window.infoTimeout = null

        var idx = choose(test)
        var attributes = pointGeometry.attributes;
        if (currentHoverIdx != null) {
          attributes.size.array[currentHoverIdx] = PARTICLE_SIZE;
        }
        currentHoverIdx = idx;

        attributes.size.array[idx] = PARTICLE_SIZE * 2;
        attributes.size.needsUpdate = true;

        if (problem.type == ProblemType.CHESS) {
          document.getElementById('info').innerHTML = createChess(loaded[idx]);
        }
        if (problem.type == ProblemType.RUBIK) {
          document.getElementById('info').innerHTML = aggregateRubik([loaded[idx]]);
        }
      }, 10);


      // Dragging
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

      if (mouseDown) {
        camera.position.x = camera.position.x - (mouse.x - mouseDownPosition.x) * (600 / camera.zoom);
        camera.position.y = camera.position.y - (mouse.y - mouseDownPosition.y) * (600 / camera.zoom);
        mouseDownPosition = normaliseMouse(event)
        camera.updateProjectionMatrix()
      }
    }







      function updatePointGeometry() {
        var i = 0
        var colors = pointGeometry.attributes.customColor.array

        segments.forEach(function(segment, si) {
          segment.vectors.forEach(function(vector, t) {
            if ((settings.showIntPoints || loaded[i].cp == 1) && vector.visible) {
              colors[i * 4 + 3] = 0.3 + (vector.age / segment.vectors.length) * 0.7;
            } else {
              colors[i * 4 + 3] = 0.0
            }

            i++
          })
        })
        pointGeometry.attributes.customColor.needsUpdate = true;

      }


			function init(data, problem) {


				var container = document.getElementById( 'container' );

				scene = new THREE.Scene();
        problem.scene = scene


        var width = container.offsetWidth;
        var height = container.offsetHeight;
				//camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0, 10000 );
        camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
        //camera.position.set(30,0,0);
        //camera.up = new THREE.Vector3(0,0,1);
        //camera.lookAt(new THREE.Vector3(0,0,0));
        camera.zoom = 4;
				camera.position.z = 1;
        camera.lookAt(new THREE.Vector3(0,0,0));

        camera.updateProjectionMatrix();

				//var vertices = new THREE.BoxGeometry( 200, 200, 200, 16, 16, 16 ).vertices;
        var vertices = new THREE.Geometry().vertices;
        var positions = new Float32Array( data.length * 3 );
				var colors = new Float32Array( data.length * 4 );
				var sizes = new Float32Array( data.length );
        var types = new Float32Array(data.length);
				var vertex;
				var color = new THREE.Color();

        var i = 0

        segments.forEach(function(segment, si) {
          segment.vectors.forEach(function(vector, t) {
            vertices.push(new THREE.Vector3(vector.x, vector.y, -0.5))

            vertex = vertices[ i ];
  					vertex.toArray( positions, i * 3 );
  					color.setHex(algorithms[data[i].algo].color);

            // Set the globalIndex which belongs to a specific vertex
            vector.globalIndex = i

            colors[i * 4] = color.r;
            colors[i * 4 + 1] = color.g;
            colors[i * 4 + 2] = color.b;
            colors[i * 4 + 3] = 0.0;

  					//color.toArray( colors, i * 4 );
  					sizes[ i ] = PARTICLE_SIZE;

            if (vector.age == 0) {
              // Starting point
              types[i] = 0
            } else if (vector.age == segment.vectors.length - 1) {
              // Ending point
              types[i] = 3
            } else if (vector.cp == 1) {
              // Checkpoint
              types[i] = 1
            } else {
              types[i] = 2
            }

            i++
          })
        })



				pointGeometry = new THREE.BufferGeometry();
				pointGeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				pointGeometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 4 ) );
				pointGeometry.addAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );
        pointGeometry.addAttribute( 'type', new THREE.BufferAttribute( types, 1 ) );

				//
				pointMaterial = new THREE.ShaderMaterial( {
					uniforms: {
            zoom: { value: 1.0 },
						color: { value: new THREE.Color( 0xffffff ) },
						pointTexture: { value: [
              new THREE.TextureLoader().load( "textures/sprites/cross_texture.png" ),
              new THREE.TextureLoader().load( "textures/sprites/square_texture.png" ),
              new THREE.TextureLoader().load( "textures/sprites/circle_texture.png" ),
              new THREE.TextureLoader().load( "textures/sprites/star_texture.png" )
            ]
             }
					},
          transparent: true,
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
					alphaTest: 0.05
				} );

				//
				particles = new THREE.Points( pointGeometry, pointMaterial );



				//
				var renderer = new THREE.WebGLRenderer({
          antialias: true
        });
        problem.renderer = renderer
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize(width, height);
        renderer.setClearColor( 0xffffff, 1);
        renderer.sortObjects = false;

        container.innerHTML = ""
				container.appendChild( renderer.domElement );
				//
				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();




        // First add lines to scene... so they get drawn first
        renderLines(segments)
        //fatLines(segments)

        updatePointGeometry()
        // Then add particles
        scene.add( particles );

        window.onwheel = function(){ return false; }
				container.addEventListener( 'mousemove', onDocumentMouseMove, false );
        container.addEventListener('mousedown', onDocumentMouseDown, false);
        container.addEventListener('mouseup', onDocumentMouseUp, false);
        container.addEventListener( 'wheel', onDocumentMouseWheel, false );
			}

      function dist(x1, y1, x2, y2) {
        var a = x1 - x2;
        var b = y1 - y2;

        var c = Math.sqrt( a*a + b*b );
        return c
      }

      function choose(position) {
        var best = 10000
        var res = 0

        for (var index = 0; index < loaded.length; index++) {
          var value = loaded[index]

          // Skip points matching some criteria
          if ((!settings.showIntPoints && value.cp == 0) || value.visible == false) {
            continue
          }

          var d = dist(position.x, position.y, value.x, value.y)

          if (d < best) {
            best = d
            res = index
          }
        }
        return res
      }

      function onDocumentMouseWheel(event) {
        event.preventDefault()
        camera.zoom = camera.zoom + event.deltaY * 0.02;
        if (camera.zoom < 1) {
          camera.zoom = 1;
        }
        pointMaterial.uniforms.zoom.value = camera.zoom;
        camera.updateProjectionMatrix();
      }

      function normaliseMouse(event) {
        var vec = {}
        vec.x = (event.clientX / window.innerWidth) * 2 - 1;
        vec.y = - (event.clientY / window.innerHeight) * 2 + 1;
        return vec
      }


			function onWindowResize() {
        var container = document.getElementById( 'container' );

        var width = container.offsetWidth;
        var height = container.offsetHeight;

				problem.renderer.setSize(width, height);

        camera.left = width / - 2
        camera.right = width / 2
        camera.top = height / 2
        camera.bottom = height / - 2

        camera.updateProjectionMatrix();
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
			}

			function render() {
        var t0 = performance.now()

				problem.renderer.render(problem.scene, camera);

        var t1 = performance.now()
			}
		</script>

	</body>
</html>
