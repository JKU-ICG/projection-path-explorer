<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>General Visualization</title>



    <script src="util.js"></script>
    <script src="https://d3js.org/d3.v4.min.js" charset="utf-8"></script>

    <script
      src="https://code.jquery.com/jquery-3.4.1.min.js"
      integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
      crossorigin="anonymous"></script>



    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>

    <script src="lib/visualization.js"></script>

    <link rel="stylesheet" href="problem_specific/chess.css">
    <link rel="stylesheet" href="problem_specific/rubik.css">

    <script src="problem_specific/rubik.js"></script>
    <script src="problem_specific/chess.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/109/three.min.js" integrity="sha256-Wua0LsQkGDEeIkbmBNjj9wcThJh5uCD6R8+5YQhXveQ=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/three.meshline@1.2.0/src/THREE.MeshLine.min.js"></script>

    <link rel="stylesheet" href="styling.css">
    <link href="rubics.png" rel="shortcut icon" type="image/x-icon" />



    <script src="LineSegmentsGeometry.js"></script>
    <script src="LineMaterial.js"></script>
    <script src="LineGeometry.js"></script>
    <script src="LineSegments2.js"></script>
    <script src="Line2.js"></script>
  </head>

  <body onresize="onWindowResize()">



    <div class="d-flex align-items-stretch" style="width: 100vw; height: 100vh">
      <div id="container" class="flex-shrink-1 flex-grow-1"></div>

      <div style="width: 18rem; margin: 0.5rem" class="card flex-shrink-0">
        <div class="d-flex align-items-center justify-content-center" style="height: 50%">
          <div class="text-center" style="width: 100%; height: 100%; position: relative">
            <div class="card-body p-2">
              <h6 class="card-title">Selected State</h5>
              <div id="info" class="d-flex align-items-stretch justify-content-center"></div>
            </div>
          </div>
        </div>
        <div class="d-flex align-items-center justify-content-center" style="height: 50%">
          <div class="text-center" style="width: 100%; height: 100%; position: relative">
            <div class="card-body p-2">
              <h6 class="card-title">State Similiarity</h5>
              <div id="aggregate" class="d-flex align-items-stretch justify-content-center"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="card flex-shrink-0" style="width: 18rem; margin: 0.5rem;">

        <div class="container" style="padding-top: 1rem;">
          <a href="#" onclick="showGuide()">show control guide</a>

          <hr>

          <div class="form-group">
            <label for="exampleFormControlSelect1">Select Dataset</label>
            <select id="setselect" name="cars" class="custom-select" onchange="selectDataset(this)">
              <option value="chess_chess16k.csv">Chess 16k Games</option>
              <option value="chess_chess40k.csv">Chess 40k Games</option>
              <option value="rubik_cube1x2_different_origins.csv">Rubik 1x2 Different Origins</option>
              <option value="rubik_cube5x2_different_origins.csv">Rubik 5x2 Different Origins</option>
              <option selected value="rubik_cube10x2_different_origins.csv">Rubik 10x2 Different Origins</option>
              <option value="rubik_cube100x2_different_origins.csv">Rubik 100x2 Different Origins</option>
              <option value="neural_rand_weights.csv">Neural Random Weights</option>
              <option value="neural_rand_confmat.csv">Neural Confusion Matrix</option>
              <option value="neural_lr_weights.csv">Neural Learning Weights</option>
              <option value="neural_lr_confmat.csv">Neural Learning Confusion Matrix</option>
            </select>
          </div>

          <hr>

          <div id="legend"></div>
        </div>
      </div>


      <div id="guide" style="position: absolute; right: 18rem; top: 2rem; display: none">
        <div class="card bg-dark text-white" style="width: 20rem; height: 20rem; opacity: 90%">
          <div class="card-body">
            <h5 class="card-title">Basic Controls</h5>

            <p class="card-text">You can move the camera by pressing the left mouse button and dragging the image.</p>
            <p class="card-text">Use your mousewheel to zoom in and out of the projection.</p>
            <p class="card-text">You can select multiple states by dragging a rectangle while pressing the ALT key.</p>
          </div>
        </div>
      </div>

    </div>





		<script type="x-shader/x-vertex" id="vertexshader">

      // Uniforms
      uniform float zoom;

      // Attributes of point sprites
      attribute float size;
      attribute vec4 customColor;
      attribute float type;

      // Varying of point sprites
			varying vec4 vColor;
      varying float vType;

			void main() {
				vColor = customColor;
        vType = type;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_PointSize = (size / 2.0) + (size / 16.0) * (zoom / 3.0);
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">
			uniform vec3 color;
			uniform sampler2D pointTexture[4];
			varying vec4 vColor;
      varying float vType;

			void main() {
        gl_FragColor = vColor;
        if (vType == 0.0) {
          gl_FragColor = gl_FragColor * texture2D(pointTexture[0], gl_PointCoord);
        } else if (vType == 1.0) {
          gl_FragColor = gl_FragColor * texture2D(pointTexture[1], gl_PointCoord);
        } else if (vType == 2.0) {
          gl_FragColor = gl_FragColor * texture2D(pointTexture[2], gl_PointCoord);
        } else {
          gl_FragColor = gl_FragColor * texture2D(pointTexture[3], gl_PointCoord);
        }

				if ( gl_FragColor.a < ALPHATEST ) discard;
			}
		</script>

		<script>




    function showGuide() {
      if (document.getElementById("guide").style.display == "none") {
        document.getElementById("guide").style.display = "block"
      } else {
        document.getElementById("guide").style.display = "none"
      }

    }


          var problem = null


          var loaded = null;
          var segments = null;
    			var camera;
    			var particles;

    			var raycaster, intersects;
    			var mouse, INTERSECTED;

          var mouseDownPosition = null;
          var mouseDown = false;
          var strokeTexture = null;

          var settings = {
            showIntPoints: true
          }

          var currentHoverIdx = null;

          function * colorGenerator() {
            while (true) {
              yield 0x7D3C98
              yield 0x148F77
              yield 0xFFC300
            }
          }
          var chooseColor = colorGenerator();

          var algorithms = { };


    /**
     * Checkbox determining if intermediate points should be drawn.
     */
    function showIntermediatePoints() {
      settings.showIntPoints = !settings.showIntPoints

      particles.update()
    }



    function onShowBeginnerMethodChanged(element) {
      // show/hide lines that belong to fridrich method
      segments.forEach((segment) => {
        if (segment.algo == 0) {
          segment.line.visible = element.checked


          segment.vectors.forEach((vector) => {
            if (vector.algo == 0) {
              vector.visible = element.checked
            }
          })
        }
      })

      particles.update()
    }

    function onShowFridrichMethodChanged(element) {
      var show = element.checked

      // show/hide lines that belong to fridrich method
      segments.forEach((segment) => {
        if (segment.algo == 1) {
          segment.line.visible = show


          segment.vectors.forEach((vector) => {
            if (vector.algo == 1) {
              vector.visible = element.checked
            }
          })
        }
      })


      particles.update()
    }



    function selectDataset(select) {
      cleanup()

      if (select.value.startsWith("chess")) {
        problem = new Problem(ProblemType.CHESS)
        loadData(problem, "datasets/chess/" + select.value.substring(6))
      } else if (select.value.startsWith("rubik")) {
        problem = new Problem(ProblemType.RUBIK)
        loadData(problem, "datasets/rubik/" + select.value.substring(6));
      } else if (select.value.startsWith("neural")) {
        problem = new Problem(ProblemType.NEURAL)
        loadData(problem, "datasets/neural/" + select.value.substring(7))
      }
    }





      var rectangleSelection = null



      function cleanup() {
        if (problem != null) {
          problem.scene.dispose()
        }
      }



      /**
       * Loads a specific problem set, creating menus, displaying vectors etc.
       */
      function loadData(problem, file) {
        chooseColor = colorGenerator();
        algorithms = {}

        setAggregateView(document.getElementById('info'), [])
        setAggregateView(document.getElementById('aggregate'), [])


        // Load csv file
        d3.csv(file, function loadCallback(error, data) {

          data.forEach(function(d) { // convert strings to numbers
            // Convert generic attributes
            d.y = +d.y
            d.x = +d.x

            if ("cubeNum" in d) {
              d.cubeNum = +d.cubeNum
            }
            if ("ep" in d) {
              d.cubeNum = +d.ep
            }


            if ("cp" in d) {
              d.cp = +d.cp
            }

            if ("algo" in d) {
              d.algo = +d.algo
            }

            if ("age" in d) {
              d.age = +d.age
            }




            // Attribute that specifies if this vector should be visible or not
            d.visible = true

            if (!(d.algo in algorithms)) {
              algorithms[d.algo] = {
                color: chooseColor.next().value
              }
            }
          });

          loaded = data;

          segments = getSegments(loaded);

          init(loaded, problem);

          particles.update()

          loadLegend(problem);

          animate();
        })
      }

      function loadLegend(problem) {
        if (problem.type == ProblemType.RUBIK) {
          document.getElementById('legend').innerHTML = rubikLegend(algorithms[1].color, algorithms[0].color)
        } else if (problem.type == ProblemType.CHESS) {
          document.getElementById('legend').innerHTML = chessLegend(algorithms[1].color, algorithms[0].color)
        } else if (problem.type == ProblemType.NEURAL) {

        }
      }




  function setAggregateView(element, list) {
    element.innerHTML = ""

    if (problem.type == ProblemType.CHESS) {
      element.innerHTML = aggregateChess(list);
    }
    if (problem.type == ProblemType.RUBIK) {
      element.innerHTML = aggregateRubik(list);
    }
  }


      function getSegments(data) {
        //creating an array holding arrays of x,y,cubenum,algo,age for each cube

        // Sort data by cubeNum
        data.sort((a, b) => a.cubeNum - b.cubeNum)


        var n = data.length
        var points = new Array()
        var currentCube = 0
        var newArray = { vectors: new Array(), algo: data[0].algo }
        for (var i = 0; i < n; i++) {
          if(data[i].cubeNum != currentCube) {
            points.push(newArray)
            currentCube = data[i].cubeNum

            newArray = { vectors: new Array(), algo: data[i].algo }
          }

          newArray.vectors.push(data[i])
        }
        points.push(newArray)
        return points
    }




function intToComponents(colorBeginner) {
    var compBeginner = {
      r: (colorBeginner & 0xff0000) >> 16,
      g: (colorBeginner & 0x00ff00) >> 8,
      b: (colorBeginner & 0x0000ff)
    };

    return compBeginner
}

    function fatLines(segments) {
      segments.forEach(function(segment, index) {
        var colors = []
        var positions = []

        var geometry = new THREE.LineGeometry();

        var matLine = new THREE.LineMaterial({
                linewidth: 2, // in pixels
                vertexColors: THREE.VertexColors,
                transparent: true,
                opacity: 0.1,
                depthWrite: false
            });
        matLine.resolution.set(776, 695);

        var da = []
        segment.vectors.forEach(function(vector, vi) {

          da.push(new THREE.Vector2(vector.x, vector.y))
          //geometry.vertices.push(new THREE.Vector3(vector.x, vector.y, -1.0));
        })

        var curve = new THREE.SplineCurve(da)
        var color = algorithms[segment.vectors[0].algo].color
        var rgb = intToComponents(color)

        curve.getPoints(1000).forEach(function(p, i) {
          positions.push(p.x, p.y, -1.0)
          colors.push(rgb.r / 255.0, rgb.g / 255.0, rgb.b / 255.0)
        })

        geometry.setPositions(positions)
        geometry.setColors(colors)

        var line = new THREE.Line2(geometry, matLine);

        // Store line data in segment...
        segment.line = line


        problem.scene.add(line)
      })
    }






    function onDocumentMouseUp(e) {

      var test = mouseToWorld(e)

      if (rectangleSelection != null) {
        rectangleSelection.mouseUp(test.x, test.y)
        rectangleSelection = null
      }


      mouseDown = false;
    }

    function onDocumentMouseDown(e) {
      e.preventDefault();

      var container = document.getElementById( 'container' );
      var width = container.offsetWidth;
      var height = container.offsetHeight;

      if (e.altKey) {
        // Selection processing
        if (rectangleSelection != null) {
          rectangleSelection.dispose()
          rectangleSelection = null
        }

        rectangleSelection = new RectangleSelection(loaded, settings, problem)

        var test = mouseToWorld(event)

        rectangleSelection.mouseDown(test.x, test.y)

      } else {
        // Dragging data around
        mouseDownPosition = normaliseMouse(e)
        mouseDown = true;
      }
    }

    function mouseToWorld(event) {
      var container = document.getElementById( 'container' );
      var width = container.offsetWidth;
      var height = container.offsetHeight;

      const rect = container.getBoundingClientRect();

      var test = {
        x: (event.clientX - rect.left - width / 2) / camera.zoom + camera.position.x,
        y: -(event.clientY - rect.top - height / 2) / camera.zoom + camera.position.y
      }

      return test
    }

    function onDocumentMouseMove( event ) {
      event.preventDefault();

      var test = mouseToWorld(event)

      if (rectangleSelection != null) {
        rectangleSelection.mouseMove(test.x, test.y)
      }

      if (window.infoTimeout != null) {
        clearTimeout(window.infoTimeout)
      }
      window.infoTimeout = setTimeout(function() {
        window.infoTimeout = null

        // Get index of selected node
        var idx = choose(test)
        particles.highlight(idx)

        var list = []
        if (idx >= 0) list.push(loaded[idx])
        setAggregateView(document.getElementById('info'), list)
      }, 10);


      // Dragging
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

      if (mouseDown) {
        camera.position.x = camera.position.x - (mouse.x - mouseDownPosition.x) * (600 / camera.zoom);
        camera.position.y = camera.position.y - (mouse.y - mouseDownPosition.y) * (600 / camera.zoom);
        mouseDownPosition = normaliseMouse(event)
        camera.updateProjectionMatrix()
      }
    }


			function init(data, problem) {
				var container = document.getElementById( 'container' );

				scene = new THREE.Scene();
        problem.scene = scene

        var width = container.offsetWidth;
        var height = container.offsetHeight;

        camera = getDefaultCamera(width, height, loaded)

        particles = new PointVisualization()
        particles.createMesh(loaded, segments)
        particles.zoom(camera.zoom)




				//
				var renderer = new THREE.WebGLRenderer({
          antialias: true
        });
        problem.renderer = renderer
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize(width, height);
        renderer.setClearColor( 0xffffff, 1);
        renderer.sortObjects = false;

        container.innerHTML = ""
				container.appendChild( renderer.domElement );
				//
				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();




        // First add lines to scene... so they get drawn first
        renderLines(segments, algorithms).forEach(line => problem.scene.add(line))
        //fatLines(segments)

        particles.update()
        // Then add particles
        scene.add( particles.mesh );

        window.onwheel = function(){ return false; }
				container.addEventListener( 'mousemove', onDocumentMouseMove, false );
        container.addEventListener('mousedown', onDocumentMouseDown, false);
        container.addEventListener('mouseup', onDocumentMouseUp, false);
        container.addEventListener( 'wheel', onDocumentMouseWheel, false );
			}

      function dist(x1, y1, x2, y2) {
        var a = x1 - x2;
        var b = y1 - y2;

        var c = Math.sqrt( a*a + b*b );
        return c
      }

      function choose(position) {
        var best = 5
        var res = -1

        for (var index = 0; index < loaded.length; index++) {
          var value = loaded[index]

          // Skip points matching some criteria
          if ((!settings.showIntPoints && value.cp == 0) || value.visible == false) {
            continue
          }

          var d = dist(position.x, position.y, value.x, value.y)

          if (d < best) {
            best = d
            res = index
          }
        }
        return res
      }

      function onDocumentMouseWheel(event) {
        event.preventDefault()
        camera.zoom = camera.zoom + event.deltaY * 0.02;
        if (camera.zoom < 1) {
          camera.zoom = 1;
        }

        particles.zoom(camera.zoom);

        camera.updateProjectionMatrix();
      }

      function normaliseMouse(event) {
        var vec = {}
        vec.x = (event.clientX / window.innerWidth) * 2 - 1;
        vec.y = - (event.clientY / window.innerHeight) * 2 + 1;
        return vec
      }


			function onWindowResize() {
        var container = document.getElementById( 'container' );

        var width = container.offsetWidth;
        var height = container.offsetHeight;

				problem.renderer.setSize(width, height);

        camera.left = width / - 2
        camera.right = width / 2
        camera.top = height / 2
        camera.bottom = height / - 2

        camera.updateProjectionMatrix();
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
			}

			function render() {
        var t0 = performance.now()

        if (problem != null && "renderer" in problem) {
          problem.renderer.render(problem.scene, camera);
        }


        var t1 = performance.now()
			}


      selectDataset(document.getElementById("setselect"))
		</script>

	</body>
</html>
